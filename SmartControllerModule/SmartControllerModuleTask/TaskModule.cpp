///////////////////////////////////////////////////////////////////////////////
// TaskModule.cpp
#include "TcPch.h"
#include <stdio.h>
#pragma hdrstop

#include "TaskModule.h"
#include "TaskModuleAds.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
DEFINE_THIS_FILE()

///////////////////////////////////////////////////////////////////////////////
// CTaskModule
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Collection of interfaces implemented by module CTaskModule
BEGIN_INTERFACE_MAP(CTaskModule)
	INTERFACE_ENTRY_ITCOMOBJECT()
	INTERFACE_ENTRY(IID_ITcADI, ITcADI)
	INTERFACE_ENTRY(IID_ITcWatchSource, ITcWatchSource)
///<AutoGeneratedContent id="InterfaceMap">
	INTERFACE_ENTRY(IID_ITcCyclic, ITcCyclic)
///</AutoGeneratedContent>
END_INTERFACE_MAP()

IMPLEMENT_ITCOMOBJECT(CTaskModule)
IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(CTaskModule)
IMPLEMENT_ITCADI(CTaskModule)
IMPLEMENT_ITCWATCHSOURCE(CTaskModule)

///////////////////////////////////////////////////////////////////////////////
// Set parameters of CTaskModule 
BEGIN_SETOBJPARA_MAP(CTaskModule)
	SETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="SetObjectParameterMap">
	SETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	SETOBJPARA_VALUE(PID_TaskModuleDefaultAdsPort, m_DefaultAdsPort)
	SETOBJPARA_VALUE(PID_Ctx_AdsPort, m_ContextAdsPort)
	SETOBJPARA_VALUE(PID_TaskModuleCounter, m_Counter)
	SETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
///</AutoGeneratedContent>
END_SETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get parameters of CTaskModule 
BEGIN_GETOBJPARA_MAP(CTaskModule)
	GETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="GetObjectParameterMap">
	GETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	GETOBJPARA_VALUE(PID_TaskModuleDefaultAdsPort, m_DefaultAdsPort)
	GETOBJPARA_VALUE(PID_Ctx_AdsPort, m_ContextAdsPort)
	GETOBJPARA_VALUE(PID_TaskModuleCounter, m_Counter)
	GETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
///</AutoGeneratedContent>
	GETOBJPARA_TYPE_CODE(PID_TaskModuleAdsPort, WORD, *p = AmsGetPort())
END_GETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get watch entries of CTaskModule
BEGIN_OBJPARAWATCH_MAP(CTaskModule)
	OBJPARAWATCH_DATAAREA_MAP()
///<AutoGeneratedContent id="ObjectParameterWatchMap">
	OBJPARAWATCH_VALUE(PID_TaskModuleCounter, m_Counter)
///</AutoGeneratedContent>
END_OBJPARAWATCH_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get data area members of CTaskModule
BEGIN_OBJDATAAREA_MAP(CTaskModule)
///<AutoGeneratedContent id="ObjectDataAreaMap">
	OBJDATAAREA_VALUE(ADI_TaskModuleInputs, m_Inputs)
	OBJDATAAREA_VALUE(ADI_TaskModuleOutputs, m_Outputs)
	OBJDATAAREA_VALUE(ADI_TaskModuleInputEtherCAT, m_InputEtherCAT)
	OBJDATAAREA_VALUE(ADI_TaskModuleOutputEtherCAT, m_OutputEtherCAT)
///</AutoGeneratedContent>
END_OBJDATAAREA_MAP()


///////////////////////////////////////////////////////////////////////////////
CTaskModule::CTaskModule()
	: m_Trace(m_TraceLevelMax, m_spSrv)
{
///<AutoGeneratedContent id="MemberInitialization">
	m_TraceLevelMax = tlAlways;
	m_DefaultAdsPort = 0;
	m_ContextAdsPort = 0;
	m_Counter = 0;
	memset(&m_Inputs, 0, sizeof(m_Inputs));
	memset(&m_Outputs, 0, sizeof(m_Outputs));
	memset(&m_InputEtherCAT, 0, sizeof(m_InputEtherCAT));
	memset(&m_OutputEtherCAT, 0, sizeof(m_OutputEtherCAT));
///</AutoGeneratedContent>

	m_cnt = 0;
	log_cnt = 0;
	Gain_Index = 0;
	m_bCount = FALSE;
	m_ButtonFlag = false;
	m_Compensator_start = 0;

	// Packet Para
	Packet_Limit = 100;

	haptic_enable = 0;

	l_m_KinClass = new Kinematics();
	l_m_PIDTorque[0] = new PIDControlClass();
	l_m_PIDTorque[1] = new PIDControlClass();
	l_m_PIDTorque[2] = new PIDControlClass();

	r_m_KinClass = new Kinematics();
	r_m_PIDTorque[0] = new PIDControlClass();
	r_m_PIDTorque[1] = new PIDControlClass();
	r_m_PIDTorque[2] = new PIDControlClass();

	l_m_Orientation = new Kinematics();
	l_m_Orientation_wrist = new Kinematics();

	r_m_Orientation = new Kinematics();
	r_m_Orientation_wrist = new Kinematics();

	l_rateModecontrol = new AlteleoperationLib();
	r_rateModecontrol = new AlteleoperationLib();
	

	for (int i = 0; i < 3; i++)
	{
		l_Torquecontroller_J[i] = new SEATorqueControl();
		r_Torquecontroller_J[i] = new SEATorqueControl();
		
		l_popcLibclass[i] = new AlpopcLib();
		r_popcLibclass[i] = new AlpopcLib();
	}

	// Torque (Nm) = Current (A) * Gear Ratio * Motor Constant / 1000.0
	// Current (A) = Torque (Nm) * 1000.0 / (Gear Ratio * Motor Constant) 
	l_Torquecontroller_J[0]->SetTorqueControlCoef(0.0f, 0.0f, 0.0f ,1000.0 / (6.5), 6.5 / 1000.0);
	l_Torquecontroller_J[1]->SetTorqueControlCoef(0.0f, 0.0f, 0.0f, 1000.0 / (6.5), 6.5 / 1000.0);
	l_Torquecontroller_J[2]->SetTorqueControlCoef(0.0f, 0.0f, 0.0f, 1000.0 / (6.5), 6.5 / 1000.0);

	r_Torquecontroller_J[0]->SetTorqueControlCoef(0.0f, 0.0f, 0.0f, 1000.0 / (6.5), 6.5 / 1000.0);
	r_Torquecontroller_J[1]->SetTorqueControlCoef(0.0f, 0.0f, 0.0f, 1000.0 / (6.5), 6.5 / 1000.0);
	r_Torquecontroller_J[2]->SetTorqueControlCoef(0.0f, 0.0f, 0.0f, 1000.0 / (6.5), 6.5 / 1000.0);

	l_Torquecontroller_J[0]->SetTorqueFrictionCoef(-0.04, 0.04, -0.35, 0.35);
	l_Torquecontroller_J[1]->SetTorqueFrictionCoef(-0.10, 0.01, 0.95, -0.05);
	l_Torquecontroller_J[2]->SetTorqueFrictionCoef(-0.10, 0.01, 0.65, -0.05);

	r_Torquecontroller_J[0]->SetTorqueFrictionCoef(-0.04, 0.04, -0.35, 0.35);
	r_Torquecontroller_J[1]->SetTorqueFrictionCoef(-0.10, 0.01, 0.95, -0.05);
	r_Torquecontroller_J[2]->SetTorqueFrictionCoef(-0.10, 0.01, 0.65, -0.05);

	l_rateModecontrol->RateMode_Initalize(0.3, 0.1, 1.2, 0.3, 0.6);
	r_rateModecontrol->RateMode_Initalize(0.3, 0.1, 1.2, 0.3, 0.6);

	l_popcLibclass[0]->POPC_Intialize(3.0, -3.0, 0.0, 0.0, 0.0);
	l_popcLibclass[1]->POPC_Intialize(3.0, -3.0, 0.0, 0.0, 0.0);
	l_popcLibclass[2]->POPC_Intialize(3.0, -3.0, 0.0, 0.0, 0.0);

	r_popcLibclass[0]->POPC_Intialize(3.0, -3.0, 0.0, 0.0, 0.0);
	r_popcLibclass[1]->POPC_Intialize(3.0, -3.0, 0.0, 0.0, 0.0);
	r_popcLibclass[2]->POPC_Intialize(3.0, -3.0, 0.0, 0.0, 0.0);

	m_button_left_prev = 0;
	m_button_left_counter = 0;
	m_button_left_filtered = 0;

	m_button_right_prev = 0;
	m_button_right_counter = 0;
	m_button_left_filtered = 0;

	l_E_slave_in[0] = 0.0;
	l_E_slave_in[1] = 0.0;
	l_E_slave_in[2] = 0.0;

	l_E_master_in[0] = 0.0;
	l_E_master_in[1] = 0.0;
	l_E_master_in[2] = 0.0;

	l_E_master_out[0] = 0.0;
	l_E_master_out[1] = 0.0;
	l_E_master_out[2] = 0.0;
	
	l_E_master_out_origin[0] = 0.0;
	l_E_master_out_origin[1] = 0.0;
	l_E_master_out_origin[2] = 0.0;
	
	l_Modified_force[0] = 0.0;
	l_Modified_force[1] = 0.0;
	l_Modified_force[2] = 0.0;

	r_E_slave_in[0] = 0.0;
	r_E_slave_in[1] = 0.0;
	r_E_slave_in[2] = 0.0;

	r_E_master_in[0] = 0.0;
	r_E_master_in[1] = 0.0;
	r_E_master_in[2] = 0.0;

	r_E_master_out[0] = 0.0;
	r_E_master_out[1] = 0.0;
	r_E_master_out[2] = 0.0;

	r_E_master_out_origin[0] = 0.0;
	r_E_master_out_origin[1] = 0.0;
	r_E_master_out_origin[2] = 0.0;

	r_Modified_force[0] = 0.0;
	r_Modified_force[1] = 0.0;
	r_Modified_force[2] = 0.0;

	/*
	m_Client_CMD.CMD_BufferL2[0] = 0.0f;
	m_Client_CMD.CMD_BufferL2[1] = 0.0f;
	m_Client_CMD.CMD_BufferL2[2] = 0.0f;

	m_Client_CMD.CMD_BufferL3[0] = 0.0f;
	m_Client_CMD.CMD_BufferL3[1] = 0.0f;
	m_Client_CMD.CMD_BufferL3[2] = 0.0f;

	m_Client_CMD.CMD_BufferL4[0] = 0.0f;
	m_Client_CMD.CMD_BufferL4[1] = 0.0f;
	m_Client_CMD.CMD_BufferL4[2] = 0.0f;

	m_Client_CMD.CMD_BufferL5[0] = 0.0f;
	m_Client_CMD.CMD_BufferL5[1] = 0.0f;
	m_Client_CMD.CMD_BufferL5[2] = 0.0f;
	
	m_Client_CMD.CMD_BufferR2[0] = 0.0f;
	m_Client_CMD.CMD_BufferR2[1] = 0.0f;
	m_Client_CMD.CMD_BufferR2[2] = 0.0f;

	m_Client_CMD.CMD_BufferR3[0] = 0.0f;
	m_Client_CMD.CMD_BufferR3[1] = 0.0f;
	m_Client_CMD.CMD_BufferR3[2] = 0.0f;

	m_Client_CMD.CMD_BufferR4[0] = 0.0f;
	m_Client_CMD.CMD_BufferR4[1] = 0.0f;
	m_Client_CMD.CMD_BufferR4[2] = 0.0f;

	m_Client_CMD.CMD_BufferR5[0] = 0.0f;
	m_Client_CMD.CMD_BufferR5[1] = 0.0f;
	m_Client_CMD.CMD_BufferR5[2] = 0.0f;
	*/

	for (int i = 0; i < 3; i++)
	{
		l_m_PIDTorque[i]->InitGain();
		l_m_PIDTorque[i]->SetKILimit(-10.0f, 10.0f);
		l_m_PIDTorque[i]->SetOutLimit(-100.0f, 100.0f);

		r_m_PIDTorque[i]->InitGain();
		r_m_PIDTorque[i]->SetKILimit(-10.0f, 10.0f);
		r_m_PIDTorque[i]->SetOutLimit(-100.0f, 100.0f);
	}


	for (int i = 0; i < 3; i++)
	{
		l_m_PIDCartesian[i] = new PIDControlClass();
		r_m_PIDCartesian[i] = new PIDControlClass();

	}

	for (int i = 0; i < 3; i++)
	{
		l_m_PIDCartesian[i]->InitGain();
		r_m_PIDCartesian[i]->InitGain();

	}
	for (int i = 0; i < 3; i++)
	{
		l_m_PIDCartesian[i]->InitGain();
		l_m_PIDCartesian[i]->SetKILimit(-10.0f, 10.0f);
		l_m_PIDCartesian[i]->SetOutLimit(-100.0f, 100.0f);

		r_m_PIDCartesian[i]->InitGain();
		r_m_PIDCartesian[i]->SetKILimit(-10.0f, 10.0f);
		r_m_PIDCartesian[i]->SetOutLimit(-100.0f, 100.0f);

	}

	testfloat = 0;

	l_cycle_time_tri = 10.0;
	l_target_time = 10.0;
	l_accel_time = 2.0;

	r_cycle_time_tri = 10.0;
	r_target_time = 10.0;
	r_accel_time = 2.0;

	l_dt = 0.001;
	r_dt = 0.001;

	for (int i = 0; i < 3; i++)
	{
		m_Client_CMD.J_AccelTime[i] = 0;
		m_Client_CMD.J_TargetTime[i] = 0;

		l_m_current_pose_prev[i] = 0.0;
		l_m_current_vel[i] = 0.0;

		r_m_current_pose_prev[i] = 0.0;
		r_m_current_vel[i] = 0.0;

	}


}

///////////////////////////////////////////////////////////////////////////////
CTaskModule::~CTaskModule() 
{
}

///////////////////////////////////////////////////////////////////////////////
// State Transitions 
///////////////////////////////////////////////////////////////////////////////
IMPLEMENT_ITCOMOBJECT_SETOBJSTATE_IP_PI(CTaskModule)

///////////////////////////////////////////////////////////////////////////////
// State transition from PREOP to SAFEOP
//
// Initialize input parameters 
// Allocate memory
HRESULT CTaskModule::SetObjStatePS(PTComInitDataHdr pInitData)
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;
	IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(pInitData);

	hr = SUCCEEDED(hr) ? InitAmsPort(m_spSrv, m_DefaultAdsPort) : hr;

	// cleanup on failure
	if (FAILED(hr))
	{
		ShutdownAmsPort();
	}
	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to OP
//
// Register with other TwinCAT objects
HRESULT CTaskModule::SetObjStateSO()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;

	// TODO: Add any additional initialization


	// If following call is successful the CycleUpdate method will be called, 
	// possibly even before this method has been left.
	hr = FAILED(hr) ? hr : AddModuleToCaller(); 

	// Cleanup if transition failed at some stage
	if ( FAILED(hr) )
	{
		RemoveModuleFromCaller(); 
	}
	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from OP to SAFEOP
HRESULT CTaskModule::SetObjStateOS()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;

	RemoveModuleFromCaller(); 

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to PREOP
HRESULT CTaskModule::SetObjStateSP()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;
	ShutdownAmsPort();

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///<AutoGeneratedContent id="ImplementationOf_ITcCyclic">
HRESULT CTaskModule::CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{
	HRESULT hr = S_OK;

	// handle pending ADS indications and confirmations
	CheckOrders();

	// TODO: Additional evaluation of input from ADS indication or confirmations

	// TODO: Submit your ADS requests 
	ULONGLONG cnt = 0;
	if (SUCCEEDED(ipTask->GetCycleCounter(&cnt)))
	{
		if (cnt%100 == 0)
		{
			SubmitAdsReadReq();
		}
	}

	if (m_bCount)        // new part
	{
		m_Counter++;
	}

	


	if (m_ButtonFlag)
	{
		

		//HEX BIN data
		UINT16 m_button_left = 0;
		
		int *m_drive1_hex_left = m_ConvertClass.DECtoHEX(m_InputEtherCAT.Axis[0].m_digital_inputs);
		int m_Joystick_hex1_left = m_drive1_hex_left[3];
		int *m_drive1_bin_left = m_ConvertClass.HEXtoBIN(m_Joystick_hex1_left);
		
		for (int i = 0; i < 4; i++){
			if (m_drive1_bin_left[i] == 0){
				switch (i)
				{
				case 0:
					m_button_left += 4;
					break;
				case 1:

					break;
				case 2:
					m_button_left += 8;
					break;
				case 3:

					break;
				}
			}
		}

		int *m_drive2_hex_left = m_ConvertClass.DECtoHEX(m_InputEtherCAT.Axis[1].m_digital_inputs);
		int m_Joystick_hex2_left = m_drive2_hex_left[3];
		int *m_drive2_bin_left = m_ConvertClass.HEXtoBIN(m_Joystick_hex2_left);

		for (int i = 0; i < 4; i++){
			if (m_drive2_bin_left[i] == 0){
				switch (i)
				{
				case 0:
					m_button_left += 2;
					break;
				case 1:	
					m_button_left += 16;
					break;
				case 2:
					m_button_left += 32;
					break;
				case 3:
					m_button_left += 1;
					break;
				}
			}
			
		}

		if (m_button_left_counter == 0)
			m_button_left_cur = m_button_left;

		if (m_button_left == m_button_left_prev)
			m_button_left_counter++;
		else if (m_button_left != m_button_left_prev)
			m_button_left_counter = 1;

		if (m_button_left_counter > BUTTON_WINDOW_SIZE)
		{
			m_button_left_filtered = m_button_left;
			m_button_left_cur = m_button_left;
			m_button_left_counter = 1;
		}
		else
		{
			m_button_left_filtered = m_button_left_cur;
		}
		m_button_left_prev = m_button_left;


		//m_logdata.m_button_left = m_button_left;
		if (m_button_left == m_button_left_prev)
		{
			m_button_left_counter++;
			if (m_button_left_counter > BUTTON_WINDOW_SIZE)
			{
				m_button_left_filtered = m_button_left;
				m_button_left_counter = 0;
			}

		}
		else
		{
			m_button_left_filtered = 0;
		}
		m_button_left_prev = m_button_left;

		//HEX BIN data
		UINT16 m_button_right = 0;

		int *m_drive1_hex_right = m_ConvertClass.DECtoHEX(m_InputEtherCAT.Axis[3].m_digital_inputs);
		int m_Joystick_hex1_right = m_drive1_hex_right[3];
		int *m_drive1_bin_right = m_ConvertClass.HEXtoBIN(m_Joystick_hex1_right);

		for (int i = 0; i < 4; i++){
			if (m_drive1_bin_right[i] == 0){
				switch (i)
				{
				case 0:
					
					break;
				case 1:
					m_button_right += 8;
					break;
				case 2:
					
					break;
				case 3:
					m_button_right += 4;
					break;
				}
			}
		}

		int *m_drive2_hex_right = m_ConvertClass.DECtoHEX(m_InputEtherCAT.Axis[4].m_digital_inputs);
		int m_Joystick_hex2_right = m_drive2_hex_right[3];
		int *m_drive2_bin_right = m_ConvertClass.HEXtoBIN(m_Joystick_hex2_right);

		for (int i = 0; i < 4; i++){
			if (m_drive2_bin_right[i] == 0){
				switch (i)
				{
				case 0:
					m_button_right += 2;
					break;
				case 1:
					m_button_right += 16;
					break;
				case 2:
					m_button_right += 32;
					break;
				case 3:
					m_button_right += 1;
					break;
				}
			}

		}

		if (m_button_right_counter == 0)
			m_button_right_cur = m_button_right;

		if (m_button_right == m_button_right_prev)
			m_button_right_counter++;
		else if (m_button_right != m_button_right_prev)
			m_button_right_counter = 1;

		if (m_button_right_counter > BUTTON_WINDOW_SIZE)
		{
			m_button_right_filtered = m_button_right;
			m_button_right_cur = m_button_right;
			m_button_right_counter = 1;
		}
		else
		{
			m_button_right_filtered = m_button_right_cur;
		}
		m_button_right_prev = m_button_right;



		//m_logdata.m_button_right = m_button_right;

		// 3 - dof manipulator motor encoder position
		l_motor_pos[0] = ((float)m_InputEtherCAT.Axis[0].m_actual_position * m_ConvertClass._ENC2RAD[0]) - l_initial_motor_pos[0];
		l_motor_pos[1] = -((float)m_InputEtherCAT.Axis[1].m_actual_position * m_ConvertClass._ENC2RAD[1]) - l_initial_motor_pos[1] + m_ConvertClass._InitDEG[1] * m_ConvertClass._DEG2RAD;
		l_motor_pos[2] = ((float)m_InputEtherCAT.Axis[2].m_actual_position * m_ConvertClass._ENC2RAD[2]) - l_initial_motor_pos[2] - m_ConvertClass._InitDEG[2] * m_ConvertClass._DEG2RAD;

		r_motor_pos[0] = -(((float)m_InputEtherCAT.Axis[3].m_actual_position * m_ConvertClass._ENC2RAD[3]) - r_initial_motor_pos[0]);
		r_motor_pos[1] = -((float)m_InputEtherCAT.Axis[4].m_actual_position * m_ConvertClass._ENC2RAD[4]) - r_initial_motor_pos[1] + m_ConvertClass._InitDEG[4] * m_ConvertClass._DEG2RAD;
		r_motor_pos[2] = ((float)m_InputEtherCAT.Axis[5].m_actual_position * m_ConvertClass._ENC2RAD[5]) - r_initial_motor_pos[2] - m_ConvertClass._InitDEG[5] * m_ConvertClass._DEG2RAD;

		// 3 - dof roll, pitch, yaw
		l_link_pos[0] = ((float)(m_InputEtherCAT.Axis[0].m_absolute_actual_position - m_ConvertClass._InitABS[0]) * m_ConvertClass._ABS2RAD[0]);
		l_link_pos[1] = ((float)(m_InputEtherCAT.Axis[1].m_absolute_actual_position - m_ConvertClass._InitABS[1]) * m_ConvertClass._ABS2RAD[1]);
		l_link_pos[2] = ((float)(m_InputEtherCAT.Axis[2].m_absolute_actual_position - m_ConvertClass._InitABS[2]) * m_ConvertClass._ABS2RAD[2]);

		r_link_pos[0] = ((float)(m_InputEtherCAT.Axis[3].m_absolute_actual_position - m_ConvertClass._InitABS[3]) / 512.0 * m_ConvertClass._ABS2RAD[3]);
		r_link_pos[1] = ((float)(m_InputEtherCAT.Axis[4].m_absolute_actual_position - m_ConvertClass._InitABS[4]) * m_ConvertClass._ABS2RAD[4]);
		r_link_pos[2] = ((float)(m_InputEtherCAT.Axis[5].m_absolute_actual_position - m_ConvertClass._InitABS[5]) / 512.0 * m_ConvertClass._ABS2RAD[5]);

		// 3 - dof manipulator motor encoder velocity
		l_motor_vel[0] = ((float)m_InputEtherCAT.Axis[0].m_actual_velocity * m_ConvertClass._ENC2RAD[0]);
		l_motor_vel[1] = -((float)m_InputEtherCAT.Axis[1].m_actual_velocity * m_ConvertClass._ENC2RAD[1]);
		l_motor_vel[2] = ((float)m_InputEtherCAT.Axis[2].m_actual_velocity * m_ConvertClass._ENC2RAD[2]);

		l_link_vel[0] = (l_link_pos[0] - l_link_pos_old[0]) / l_dt;
		l_link_vel[1] = (l_link_pos[1] - l_link_pos_old[1]) / l_dt;
		l_link_vel[2] = (l_link_pos[2] - l_link_pos_old[2]) / l_dt;

		l_link_pos_old[0] = l_link_pos[0];
		l_link_pos_old[1] = l_link_pos[1];
		l_link_pos_old[2] = l_link_pos[2];

		r_motor_vel[0] = -((float)m_InputEtherCAT.Axis[3].m_actual_velocity * m_ConvertClass._ENC2RAD[3]);
		r_motor_vel[1] = -((float)m_InputEtherCAT.Axis[4].m_actual_velocity * m_ConvertClass._ENC2RAD[4]);
		r_motor_vel[2] = ((float)m_InputEtherCAT.Axis[5].m_actual_velocity * m_ConvertClass._ENC2RAD[5]);

		r_link_vel[0] = (r_link_pos[0] - r_link_pos_old[0]) / r_dt;
		r_link_vel[1] = (r_link_pos[1] - r_link_pos_old[1]) / r_dt;
		r_link_vel[2] = (r_link_pos[2] - r_link_pos_old[2]) / r_dt;

		r_link_pos_old[0] = r_link_pos[0];
		r_link_pos_old[1] = r_link_pos[1];
		r_link_pos_old[2] = r_link_pos[2];


		l_current_pos[0] = l_motor_pos[0];
		l_current_pos[1] = l_motor_pos[1];
		l_current_pos[2] = l_motor_pos[2];

		r_current_pos[0] = r_motor_pos[0];
		r_current_pos[1] = r_motor_pos[1];
		r_current_pos[2] = r_motor_pos[2];

		l_current_tor[0] = l_Torquecontroller_J[0]->InputCurrentCalculation((float)m_InputEtherCAT.Axis[0].m_actual_current);
		l_current_tor[1] = l_Torquecontroller_J[1]->InputCurrentCalculation((float)m_InputEtherCAT.Axis[1].m_actual_current);
		l_current_tor[2] = l_Torquecontroller_J[2]->InputCurrentCalculation((float)m_InputEtherCAT.Axis[2].m_actual_current);

		r_current_tor[0] = r_Torquecontroller_J[0]->InputCurrentCalculation((float)m_InputEtherCAT.Axis[3].m_actual_current);
		r_current_tor[1] = r_Torquecontroller_J[1]->InputCurrentCalculation((float)m_InputEtherCAT.Axis[4].m_actual_current);
		r_current_tor[2] = r_Torquecontroller_J[2]->InputCurrentCalculation((float)m_InputEtherCAT.Axis[5].m_actual_current);

		float* L_l_current_pose = l_m_KinClass->ForwardKinPos(l_motor_pos[0], l_motor_pos[1], l_motor_pos[2]);

		// Cartesian Position 
		l_m_current_pose[0] = -1.0 * L_l_current_pose[0];
		l_m_current_pose[1] = -1.0 * L_l_current_pose[1];
		l_m_current_pose[2] = L_l_current_pose[2];

		l_m_current_vel[0] = (l_m_current_pose[0] - l_m_current_pose_prev[0]);
		l_m_current_vel[1] = (l_m_current_pose[1] - l_m_current_pose_prev[1]);
		l_m_current_vel[2] = (l_m_current_pose[2] - l_m_current_pose_prev[2]);

		l_m_current_pose_prev[0] = l_m_current_pose[0];
		l_m_current_pose_prev[1] = l_m_current_pose[1];
		l_m_current_pose_prev[2] = l_m_current_pose[2];
		

		float* L_l_Orientation = l_m_Orientation->Orientation(l_motor_pos[0], l_motor_pos[1], l_motor_pos[2], l_link_pos[0]);
		l_yaw = L_l_Orientation[2];

		float* L_l_Orientation_wrist = l_m_Orientation_wrist->Orientation_wrist(3.14 / 2, l_link_pos[0], l_link_pos[1], l_link_pos[2]);
		l_roll = L_l_Orientation_wrist[0];
		l_pitch = L_l_Orientation_wrist[1];


		float* R_l_current_pose = r_m_KinClass->ForwardKinPos(r_motor_pos[0], r_motor_pos[1], r_motor_pos[2]);

		r_m_current_pose[0] = -1.0 * R_l_current_pose[0];
		r_m_current_pose[1] = -1.0 * R_l_current_pose[1];
		r_m_current_pose[2] = R_l_current_pose[2];

		r_m_current_vel[0] = (r_m_current_pose[0] - r_m_current_pose_prev[0]);
		r_m_current_vel[1] = (r_m_current_pose[1] - r_m_current_pose_prev[1]);
		r_m_current_vel[2] = (r_m_current_pose[2] - r_m_current_pose_prev[2]);

		r_m_current_pose_prev[0] = r_m_current_pose[0];
		r_m_current_pose_prev[1] = r_m_current_pose[1];
		r_m_current_pose_prev[2] = r_m_current_pose[2];

		float* R_l_Orientation = r_m_Orientation->Orientation(r_motor_pos[0], r_motor_pos[1], r_motor_pos[2], r_link_pos[0]);
		r_yaw = R_l_Orientation[2];

		float* R_l_Orientation_wrist = r_m_Orientation_wrist->Orientation_wrist(-3.14 / 2, r_link_pos[0], r_link_pos[1], r_link_pos[2]);
		r_roll = -1*R_l_Orientation_wrist[0];
		r_pitch = -1*R_l_Orientation_wrist[1];


		// Mass Matrix, Coriolis Matrix, Gravity Matrix
		//float(*l_massmatrix)[3] = l_m_KinClass->MassMat(l_motor_pos[1], l_motor_pos[2]);
		//float(*l_coriolis_matrix)[3] = l_m_KinClass->CoriolisMat(l_motor_pos[0], l_motor_pos[1], l_motor_pos[2], l_motor_vel[0], l_motor_vel[1], l_motor_vel[2]);
		float* l_grav_matrix = l_m_KinClass->GravityMat(l_motor_pos[1], l_motor_pos[2]);

		//float(*r_massmatrix)[3] = r_m_KinClass->MassMat(r_motor_pos[1], r_motor_pos[2]);
		//float(*r_coriolis_matrix)[3] = r_m_KinClass->CoriolisMat(r_motor_pos[0], r_motor_pos[1], r_motor_pos[2], r_motor_vel[0], r_motor_vel[1], r_motor_vel[2]);
		float* r_grav_matrix = r_m_KinClass->GravityMat(r_motor_pos[1], r_motor_pos[2]);

		l_m_grav_matrix[0] = 0.0;
		l_m_grav_matrix[1] = l_grav_matrix[1];
		l_m_grav_matrix[2] = l_grav_matrix[2];


		r_m_grav_matrix[0] = 0.0;
		r_m_grav_matrix[1] = r_grav_matrix[1];
		r_m_grav_matrix[2] = r_grav_matrix[2];

		
		
		for (int i = 0; i < 3; i++){

			l_temp_gain_02[i] = m_Client_CMD.CMD_BufferL2[i];
			l_temp_gain_03[i] = m_Client_CMD.CMD_BufferL3[i];
			

			r_temp_gain_02[i] = m_Client_CMD.CMD_BufferR2[i];
			r_temp_gain_03[i] = m_Client_CMD.CMD_BufferR3[i];
		}

		l_temp_gain_04[0] = m_Client_CMD.CMD_BufferL4[0];
		l_temp_gain_04[1] = m_Client_CMD.CMD_BufferL5[0];
		l_temp_gain_04[2] = m_Client_CMD.CMD_BufferL6[0];

		l_temp_gain_05[0] = m_Client_CMD.CMD_BufferL4[1];
		l_temp_gain_05[1] = m_Client_CMD.CMD_BufferL5[1];
		l_temp_gain_05[2] = m_Client_CMD.CMD_BufferL6[1];
		
		r_temp_gain_04[0] = m_Client_CMD.CMD_BufferR4[0];
		r_temp_gain_04[1] = m_Client_CMD.CMD_BufferR5[0];
		r_temp_gain_04[2] = m_Client_CMD.CMD_BufferR6[0];

		r_temp_gain_05[0] = m_Client_CMD.CMD_BufferR4[1];
		r_temp_gain_05[1] = m_Client_CMD.CMD_BufferR5[1];
		r_temp_gain_05[2] = m_Client_CMD.CMD_BufferR6[1];
		

		l_Torquecontroller_J[0]->SetTorqueFrictionCoef(l_temp_gain_04[0], l_temp_gain_05[0], l_temp_gain_02[0], l_temp_gain_03[0]);
		l_Torquecontroller_J[1]->SetTorqueFrictionCoef(l_temp_gain_04[1], l_temp_gain_05[1], l_temp_gain_02[1], l_temp_gain_03[1]);
		l_Torquecontroller_J[2]->SetTorqueFrictionCoef(l_temp_gain_04[2], l_temp_gain_05[2], l_temp_gain_02[2], l_temp_gain_03[2]);

		r_Torquecontroller_J[0]->SetTorqueFrictionCoef(-r_temp_gain_04[0], -r_temp_gain_05[0], -r_temp_gain_02[0], -r_temp_gain_03[0]);
		r_Torquecontroller_J[1]->SetTorqueFrictionCoef(r_temp_gain_04[1], r_temp_gain_05[1], r_temp_gain_02[1], r_temp_gain_03[1]);
		r_Torquecontroller_J[2]->SetTorqueFrictionCoef(r_temp_gain_04[2], r_temp_gain_05[2], r_temp_gain_02[2], r_temp_gain_03[2]);


		l_m_friction_compensator[0] = l_Torquecontroller_J[0]->TorqueFriction(l_motor_vel[0]);
		l_m_friction_compensator[1] = l_Torquecontroller_J[1]->TorqueFriction(l_motor_vel[1]);
		l_m_friction_compensator[2] = l_Torquecontroller_J[2]->TorqueFriction(l_motor_vel[2]);


		r_m_friction_compensator[0] = r_Torquecontroller_J[0]->TorqueFriction(r_motor_vel[0]);
		r_m_friction_compensator[1] = r_Torquecontroller_J[1]->TorqueFriction(r_motor_vel[1]);
		r_m_friction_compensator[2] = r_Torquecontroller_J[2]->TorqueFriction(r_motor_vel[2]);

		float(*l_current_jacobtrans)[3];
		float(*l_current_mjacobtrans)[3];

		float(*r_current_jacobtrans)[3];
		float(*r_current_mjacobtrans)[3];

		
		l_m_pose_PID_Out[0] = left_popc.force[0];
		l_m_pose_PID_Out[1] = left_popc.force[1];
		l_m_pose_PID_Out[2] = left_popc.force[2];
		l_E_slave_in[0] = left_popc.s_energy[0];
		l_E_slave_in[1] = left_popc.s_energy[1];
		l_E_slave_in[2] = left_popc.s_energy[2];

			
		r_m_pose_PID_Out[0] = right_popc.force[0];
		r_m_pose_PID_Out[1] = right_popc.force[1];
		r_m_pose_PID_Out[2] = right_popc.force[2];
		r_E_slave_in[0] = right_popc.s_energy[0];
		r_E_slave_in[1] = right_popc.s_energy[1];
		r_E_slave_in[2] = right_popc.s_energy[2];

		
				
		/////////////////////////////////////////////////////////
		//
		// * ADS Client Data Update
		// 
		/////////////////////////////////////////////////////////  

		m_logdata.m_Cnt[log_cnt % Packet_Limit] = m_cnt;
		m_logdata.m_log_cnt = log_cnt;

		for (int i = 0; i < 3; i++)
		{

			////////////////////////////////////////////////////
			///////////// Left Side Paramter ///////////////////
			///////////////////////////////////////////////////
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].mode_of_operation[i] = m_OutputEtherCAT.Axis[i].m_mode_of_operation;
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].status_word[i] = m_InputEtherCAT.Axis[i].m_status_word;
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].actual_motor_position[i] = l_motor_pos[i];
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].actual_link_position[i] = l_m_current_pose[i];
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].actual_motor_velocity[i] = l_motor_vel[i];
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].actual_link_velocity[i] = l_m_current_vel[i];

			m_logdata.m_Axis_L[log_cnt % Packet_Limit].actual_current[i] = l_m_pose_VSD_Torq[i];
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].target_position[i] = 0.0;
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].target_velocity[i] = m_OutputEtherCAT.Axis[i].m_target_velocity;
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].target_current[i] = l_grav_matrix[i];
			
			
			m_logdata.accel_time[i] = m_Client_CMD.J_AccelTime[i];
			m_logdata.target_reach_time[i] = m_Client_CMD.J_TargetTime[i];

			//Cartesian Position Update
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].cartesian_target_pose[i] = 0.0;
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].cartesian_current_pose[i] = l_m_current_pose[i];
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].energy[i] = l_E_master_in[i];
			
			// POPC data logging
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].E_slave_in[i] = l_E_slave_in[i];
			
			
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].E_master_out_origin[i] = l_E_master_out_origin[i];
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].E_master_out[i] = l_E_master_out[i];
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].Fm[i] = l_m_pose_PID_Out[i];
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].F_modified[i] = l_Modified_force[i];
			m_logdata.m_Axis_L[log_cnt % Packet_Limit].Vm[i] = l_m_current_vel[i];
			

			////////////////////////////////////////////////////
			///////////// Right Side Paramter //////////////////
			///////////////////////////////////////////////////

			m_logdata.m_Axis_R[log_cnt % Packet_Limit].mode_of_operation[i] = m_OutputEtherCAT.Axis[i+3].m_mode_of_operation;
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].status_word[i] = m_InputEtherCAT.Axis[i + 3].m_status_word;
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].actual_motor_position[i] = r_motor_pos[i];
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].actual_link_position[i] = r_m_current_pose[i];
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].actual_motor_velocity[i] = r_motor_vel[i];
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].actual_link_velocity[i] = r_m_current_vel[i];

			m_logdata.m_Axis_R[log_cnt % Packet_Limit].actual_current[i] = r_m_pose_VSD_Torq[i];
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].target_position[i] = 0.0;
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].target_velocity[i] = m_OutputEtherCAT.Axis[i + 3].m_target_velocity;
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].target_current[i] = r_grav_matrix[i];



			//Cartesian Position Update
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].cartesian_target_pose[i] = 0.0;
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].cartesian_current_pose[i] = r_m_current_pose[i];
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].energy[i] = r_E_master_in[i];

			// POPC data logging
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].E_slave_in[i] = r_E_slave_in[i];
			
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].E_master_out_origin[i] = r_E_master_out_origin[i];
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].E_master_out[i] = r_E_master_out[i];
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].Fm[i] = r_m_pose_PID_Out[i];
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].F_modified[i] = r_Modified_force[i];
			m_logdata.m_Axis_R[log_cnt % Packet_Limit].Vm[i] = r_m_current_vel[i];
			
			//m_logdata.accel_time[i] = m_Client_CMD.J_AccelTime[i];
			//m_logdata.target_reach_time[i] = m_Client_CMD.J_TargetTime[i];

			

		}
		//m_logdata.m_Axis_L[log_cnt % Packet_Limit].m_button_left = m_button_left;
		m_logdata.m_Axis_L[log_cnt % Packet_Limit].m_button_left_filtered = m_button_left_filtered;
		m_logdata.m_Axis_L[log_cnt % Packet_Limit].cartesian_current_orientation[0] = l_roll;
		m_logdata.m_Axis_L[log_cnt % Packet_Limit].cartesian_current_orientation[1] = l_pitch;
		m_logdata.m_Axis_L[log_cnt % Packet_Limit].cartesian_current_orientation[2] = l_yaw;

		//m_logdata.m_Axis_R[log_cnt % Packet_Limit].m_button_right = m_button_right;
		m_logdata.m_Axis_R[log_cnt % Packet_Limit].m_button_right_filtered = m_button_right_filtered;
		m_logdata.m_Axis_R[log_cnt % Packet_Limit].cartesian_current_orientation[0] = r_roll;
		m_logdata.m_Axis_R[log_cnt % Packet_Limit].cartesian_current_orientation[1] = r_pitch;
		m_logdata.m_Axis_R[log_cnt % Packet_Limit].cartesian_current_orientation[2] = r_yaw;

		// * Time Update
		log_cnt++; // ADS Client Update Data TIme
		m_cnt++;   // Master System Counter

		int l_temp_torque_int[3];
		int r_temp_torque_int[3];

		for (int i = 0; i < 3; i++)
		{
			l_target_tor[i] = l_m_grav_matrix[i] + l_m_friction_compensator[i];
			r_target_tor[i] = r_m_grav_matrix[i] + r_m_friction_compensator[i];
			//target_tor[i] = m_grav_matrix[i];
		}

		/////////////////////////////////////////////////////////
		//
		// * ADS Client Button Select (cyclic loop)
		// 
		/////////////////////////////////////////////////////////  

		switch (m_ButtonSet)
		{

		case ButtonServoOn:
			for (int i = 0; i < 6; i++)
			{
				if (m_InputEtherCAT.Axis[i].m_status_word != 0x0237 &&
					m_InputEtherCAT.Axis[i].m_status_word != 0x1237 &&
					m_InputEtherCAT.Axis[i].m_status_word != 0x0233 &&
					m_InputEtherCAT.Axis[i].m_status_word != 0x1233 &&
					m_InputEtherCAT.Axis[i].m_status_word != 0x0231 &&
					m_InputEtherCAT.Axis[i].m_status_word != 0x1231)
				{
					m_OutputEtherCAT.Axis[i].m_control_word = 0x06;
				}
				else if (m_InputEtherCAT.Axis[i].m_status_word == 0x0231 ||
					m_InputEtherCAT.Axis[i].m_status_word == 0x1231)
				{
					m_OutputEtherCAT.Axis[i].m_control_word = 0x07;
				}
				else if (m_InputEtherCAT.Axis[i].m_status_word == 0x0233 ||
					m_InputEtherCAT.Axis[i].m_status_word == 0x1233)
				{
					m_OutputEtherCAT.Axis[i].m_control_word = 0x0f;
					//m_ButtonSet = 0x00;
					//m_ButtonSet = Watingstate;
				}
			}
			m_ButtonSet = Watingstate;
			break;

		case Watingstate:

			m_OutputEtherCAT.Axis[0].m_target_current = l_m_grav_matrix[0];
			m_OutputEtherCAT.Axis[1].m_target_current = l_m_grav_matrix[1];
			m_OutputEtherCAT.Axis[2].m_target_current = l_m_grav_matrix[2];

			m_OutputEtherCAT.Axis[3].m_target_current = r_m_grav_matrix[0];
			m_OutputEtherCAT.Axis[4].m_target_current = r_m_grav_matrix[1];
			m_OutputEtherCAT.Axis[5].m_target_current = r_m_grav_matrix[2];

			// Gravity Mode Check
			m_logdata.m_dSystemMode = 0;
			//Position Mode Check
			m_logdata.TorquePosition_Mode = 0;
			break;

		case ButtonCartesianMove:

			m_ButtonSet = InitCartesianPoseComplete;

			break;

		case InitCartesianPoseComplete:

			l_m_pose_VSD_Torq[0] = 0;
			l_m_pose_VSD_Torq[1] = 0;
			l_m_pose_VSD_Torq[2] = 0;

			r_m_pose_VSD_Torq[0] = 0;
			r_m_pose_VSD_Torq[1] = 0;
			r_m_pose_VSD_Torq[2] = 0;
			/*
			// Cartesian Space PID Output
			for (int ii = 0; ii < 3; ii++)
			{
				l_m_pose_PID_Out[ii] = 0.0;
				r_m_pose_PID_Out[ii] = 0.0;
				//m_pose_PID_Out[ii] = OutputForce[ii]);
			}
			*/
			

			l_popcLibclass[0]->ImpedancePOPC_NonVMS(l_E_slave_in[0], l_E_master_in[0], l_E_master_out_origin[0], l_E_master_out[0],
				l_m_pose_PID_Out[0], l_Modified_force[0], l_m_current_vel[0], 0.001);
			l_popcLibclass[1]->ImpedancePOPC_NonVMS(l_E_slave_in[1], l_E_master_in[1], l_E_master_out_origin[1], l_E_master_out[1],
				l_m_pose_PID_Out[1], l_Modified_force[1], l_m_current_vel[1], 0.001);
			l_popcLibclass[2]->ImpedancePOPC_NonVMS(l_E_slave_in[2], l_E_master_in[2], l_E_master_out_origin[2], l_E_master_out[2],
				l_m_pose_PID_Out[2], l_Modified_force[2], l_m_current_vel[2], 0.001);

			r_popcLibclass[0]->ImpedancePOPC_NonVMS(r_E_slave_in[0], r_E_master_in[0], r_E_master_out_origin[0], r_E_master_out[0],
				r_m_pose_PID_Out[0], r_Modified_force[0], r_m_current_vel[0], 0.001);
			r_popcLibclass[1]->ImpedancePOPC_NonVMS(r_E_slave_in[1], r_E_master_in[1], r_E_master_out_origin[1], r_E_master_out[1],
				r_m_pose_PID_Out[1], r_Modified_force[1], r_m_current_vel[1], 0.001);
			r_popcLibclass[2]->ImpedancePOPC_NonVMS(r_E_slave_in[2], r_E_master_in[2], r_E_master_out_origin[2], r_E_master_out[2],
				r_m_pose_PID_Out[2], r_Modified_force[2], r_m_current_vel[2], 0.001);

			l_current_jacobtrans = l_m_KinClass->JacobianTransPose(l_motor_pos[0], l_motor_pos[1], l_motor_pos[2]);
			r_current_jacobtrans = r_m_KinClass->JacobianTransPose(r_motor_pos[0], r_motor_pos[1], r_motor_pos[2]);

			for (int x = 0; x < 3; x++)
			{
				for (int y = 0; y < 3; y++)
				{
					l_m_current_jacobtrans[x][y] = l_current_jacobtrans[x][y];
					r_m_current_jacobtrans[x][y] = r_current_jacobtrans[x][y];
				}
			}

			for (int ii = 0; ii < 3; ii++)
			{
				l_m_pose_VSD_Torq[ii] = (l_m_current_jacobtrans[ii][0] * (l_Modified_force[0]) + l_m_current_jacobtrans[ii][1] * (l_Modified_force[1]) + l_m_current_jacobtrans[ii][2] * (l_Modified_force[2]));
				r_m_pose_VSD_Torq[ii] = (r_m_current_jacobtrans[ii][0] * (r_Modified_force[0]) + r_m_current_jacobtrans[ii][1] * (r_Modified_force[1]) + r_m_current_jacobtrans[ii][2] * (r_Modified_force[2]));
			}


			/*
			l_target_tor[0] = l_m_grav_matrix[0] + l_m_pose_VSD_Torq[0];
			l_target_tor[1] = l_m_grav_matrix[1] + l_m_pose_VSD_Torq[1];
			l_target_tor[2] = l_m_grav_matrix[2] + l_m_pose_VSD_Torq[2];

			r_target_tor[0] = r_m_grav_matrix[0] + r_m_pose_VSD_Torq[0];
			r_target_tor[1] = r_m_grav_matrix[1] + r_m_pose_VSD_Torq[1];
			r_target_tor[2] = r_m_grav_matrix[2] + r_m_pose_VSD_Torq[2];
			*/
			//Position Mode Check
			m_logdata.TorquePosition_Mode = 1;
			break;

		case ButtonStop:
			m_ButtonSet = Watingstate;

			break;

		default:
			break;


		}

		//test
		//target_tor[0] = 0.0;
		//target_tor[1] = 0.0;
		//target_tor[2] = 0.0;

		l_temp_gain_01[0] = m_Client_CMD.CMD_BufferL1[0];
		l_temp_gain_01[1] = m_Client_CMD.CMD_BufferL1[1];
		l_temp_gain_01[2] = m_Client_CMD.CMD_BufferL1[2];
		
		r_temp_gain_01[0] = m_Client_CMD.CMD_BufferR1[0];
		r_temp_gain_01[1] = m_Client_CMD.CMD_BufferR1[1];
		r_temp_gain_01[2] = m_Client_CMD.CMD_BufferR1[2];
		

		/*
		l_temp_torque_int[0] = (int)(l_Torquecontroller_J[0]->OutputTorqueCalculation(l_target_tor[0]) * l_temp_gain_01[0]);
		l_temp_torque_int[1] = (int)(l_Torquecontroller_J[1]->OutputTorqueCalculation(l_target_tor[1]) * l_temp_gain_01[1]);
		l_temp_torque_int[2] = (int)(l_Torquecontroller_J[2]->OutputTorqueCalculation(l_target_tor[2]) * l_temp_gain_01[2] * -1.0f);

		r_temp_torque_int[0] = (int)(r_Torquecontroller_J[0]->OutputTorqueCalculation(r_target_tor[0]) * r_temp_gain_01[0] * -1.0f);
		r_temp_torque_int[1] = (int)(r_Torquecontroller_J[1]->OutputTorqueCalculation(r_target_tor[1]) * r_temp_gain_01[1]);
		r_temp_torque_int[2] = (int)(r_Torquecontroller_J[2]->OutputTorqueCalculation(r_target_tor[2]) * r_temp_gain_01[2] * -1.0f);
		*/
		if (m_Compensator_start == 1) {
			if (haptic_enable == 1)
			{
				l_temp_torque_int[0] = (int)(l_Torquecontroller_J[0]->OutputTorqueCalculation(l_m_grav_matrix[0] * l_temp_gain_01[0] + l_m_friction_compensator[0] + l_m_pose_VSD_Torq[0] * 0.0001));
				l_temp_torque_int[1] = (int)(l_Torquecontroller_J[1]->OutputTorqueCalculation(l_m_grav_matrix[1] * l_temp_gain_01[1] + l_m_friction_compensator[1] + l_m_pose_VSD_Torq[1] * 0.0001));
				l_temp_torque_int[2] = (int)(l_Torquecontroller_J[2]->OutputTorqueCalculation(l_m_grav_matrix[2] * l_temp_gain_01[2] + l_m_friction_compensator[2] + l_m_pose_VSD_Torq[2] * 0.0001) * -1.0f);

				r_temp_torque_int[0] = (int)(r_Torquecontroller_J[0]->OutputTorqueCalculation(l_m_grav_matrix[0] * r_temp_gain_01[0] + r_m_friction_compensator[0] + r_m_pose_VSD_Torq[0] * 0.0001) * -1.0f);
				r_temp_torque_int[1] = (int)(r_Torquecontroller_J[1]->OutputTorqueCalculation(l_m_grav_matrix[1] * r_temp_gain_01[1] + r_m_friction_compensator[1] + r_m_pose_VSD_Torq[1] * 0.0001));
				r_temp_torque_int[2] = (int)(r_Torquecontroller_J[2]->OutputTorqueCalculation(l_m_grav_matrix[2] * r_temp_gain_01[2] + r_m_friction_compensator[2] + r_m_pose_VSD_Torq[2] * 0.0001)  * -1.0f);

			}
			else {
				l_temp_torque_int[0] = (int)(l_Torquecontroller_J[0]->OutputTorqueCalculation(l_m_grav_matrix[0] * l_temp_gain_01[0] + l_m_friction_compensator[0]));
				l_temp_torque_int[1] = (int)(l_Torquecontroller_J[1]->OutputTorqueCalculation(l_m_grav_matrix[1] * l_temp_gain_01[1] + l_m_friction_compensator[1]));
				l_temp_torque_int[2] = (int)(l_Torquecontroller_J[2]->OutputTorqueCalculation(l_m_grav_matrix[2] * l_temp_gain_01[2] + l_m_friction_compensator[2]) * -1.0f);

				r_temp_torque_int[0] = (int)(r_Torquecontroller_J[0]->OutputTorqueCalculation(l_m_grav_matrix[0] * r_temp_gain_01[0] + r_m_friction_compensator[0]) * -1.0f);
				r_temp_torque_int[1] = (int)(r_Torquecontroller_J[1]->OutputTorqueCalculation(l_m_grav_matrix[1] * r_temp_gain_01[1] + r_m_friction_compensator[1]));
				r_temp_torque_int[2] = (int)(r_Torquecontroller_J[2]->OutputTorqueCalculation(l_m_grav_matrix[2] * r_temp_gain_01[2] + r_m_friction_compensator[2])  * -1.0f);

			}

		}
		else{
			l_temp_torque_int[0] = 0;
			l_temp_torque_int[1] = 0;
			l_temp_torque_int[2] = 0;

			r_temp_torque_int[0] = 0;
			r_temp_torque_int[1] = 0;
			r_temp_torque_int[2] = 0;
		}

		m_OutputEtherCAT.Axis[0].m_target_current = l_temp_torque_int[0];
		m_OutputEtherCAT.Axis[1].m_target_current = l_temp_torque_int[1];
		m_OutputEtherCAT.Axis[2].m_target_current = l_temp_torque_int[2];

		m_OutputEtherCAT.Axis[3].m_target_current = r_temp_torque_int[0];
		m_OutputEtherCAT.Axis[4].m_target_current = r_temp_torque_int[1];
		m_OutputEtherCAT.Axis[5].m_target_current = r_temp_torque_int[2];

		// Joint Torque monitoring
		m_logdata.TestBuffer1[0] = r_current_tor[0];
		m_logdata.TestBuffer1[1] = r_current_tor[1];
		m_logdata.TestBuffer1[2] = r_current_tor[2];

		m_logdata.TestBuffer2[0] = r_m_grav_matrix[0];
		m_logdata.TestBuffer2[1] = r_m_grav_matrix[1];
		m_logdata.TestBuffer2[2] = r_m_grav_matrix[2];

		m_logdata.TestBuffer3[0] = r_m_grav_matrix[0] - r_current_tor[0];
		m_logdata.TestBuffer3[1] = r_m_grav_matrix[1] - r_current_tor[1];
		m_logdata.TestBuffer3[2] = r_m_grav_matrix[2] - r_current_tor[2];

	}


	return hr;
}
///</AutoGeneratedContent>

///////////////////////////////////////////////////////////////////////////////
HRESULT CTaskModule::AddModuleToCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;
	if ( m_spCyclicCaller.HasOID() )
	{
		if ( SUCCEEDED_DBG(hr = m_spSrv->TcQuerySmartObjectInterface(m_spCyclicCaller)) )
		{
			if ( FAILED(hr = m_spCyclicCaller->AddModule(m_spCyclicCaller, THIS_CAST(ITcCyclic))) )
			{
				m_spCyclicCaller = NULL;
			}
		}
	}
	else
	{
		hr = ADS_E_INVALIDOBJID; 
		SUCCEEDED_DBGT(hr, "Invalid OID specified for caller task");
	}
	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
VOID CTaskModule::RemoveModuleFromCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	if ( m_spCyclicCaller )
	{
		m_spCyclicCaller->RemoveModule(m_spCyclicCaller);
	}
	m_spCyclicCaller	= NULL;
	m_Trace.Log(tlVerbose, FLEAVEA);
}

///////////////////////////////////////////////////////////////////////////////
void CTaskModule::AdsReadWriteInd
(
	AmsAddr& rAddr, 
	ULONG invokeId, 
	ULONG indexGroup,
	ULONG indexOffset, 
	ULONG cbReadLength, 
	ULONG cbWriteLength, 
	PVOID pData 
)
{
	m_Trace.Log(tlVerbose, FENTERA "oid=0x%08x, invokeId=%d, indexGroup=0x%08x, indexOffset=0x%08x, cbReadLength=%d, cbWriteLength=%d, pData=0x%p",
		m_objId.value, invokeId, indexGroup, indexOffset, cbReadLength, cbWriteLength, pData);
	
	static int n = 0;

	switch(indexGroup)
	{
		case TaskModuleIndexGroup1:
			switch (indexOffset)
			{

			case TaskModuleIndexOffset1:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				// TODO: add custom code here
				m_bCount = TRUE; // received IG=1 IO=1, start counter (sample code)

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 0, NULL);
				break;

			case TaskModuleIndexOffset2:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				// TODO: add custom code here
				pData = &m_Counter;         // received IG=1 IO=2, provide counter value via ADS (sample code)
				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 8, pData); //sample code
				//sample code: original content: AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 0, NULL); 
				break;
			}
			break;
		case TaskModuleIndexGroup2:
			switch (indexOffset)
			{

			case TaskModuleIndexOffset1:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				m_bCount = FALSE;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 8, pData); //sample code
				//sample code: original content: AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 0, NULL); 
				break;

			case TaskModuleIndexOffset2:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);


				pData = &m_Counter;
				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 8, pData); //sample code
				//sample code: original content: AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 0, NULL); 
				break;
			}
			break;

		case IG_OVERWRITE:

			switch (indexOffset)
			{
			case TaskModuleIndexOffset1:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				unsigned long *pCounter = (unsigned long*)pData;
				m_Counter = *pCounter;
				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;
			}
			break;

		case GUIButton:
			unsigned long *pCounter;
			float *pCountFloat;
			int *pCountInt;
			ADSPOPC_SystemData *pCountData;

			switch (indexOffset)
			{
				// Servo On
			case TaskModuleIndexOffset1:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				m_ButtonFlag = true;
				m_ButtonSet = ButtonServoOn;

				for (int i = 0; i < 6; i++)
				{
					m_OutputEtherCAT.Axis[i].m_mode_of_operation = 10;
					m_OutputEtherCAT.Axis[i].m_target_position = m_InputEtherCAT.Axis[i].m_actual_position;
					m_OutputEtherCAT.Axis[i].m_target_velocity = 0x00;
					m_OutputEtherCAT.Axis[i].m_target_current = 0x00;
					m_OutputEtherCAT.Axis[i].m_control_word = 0x00;
				}

				m_OutputEtherCAT.Axis[0].m_Max_Current = 1000;
				m_OutputEtherCAT.Axis[1].m_Max_Current = 1000;
				m_OutputEtherCAT.Axis[2].m_Max_Current = 1000;
				m_OutputEtherCAT.Axis[3].m_Max_Current = 1000;
				m_OutputEtherCAT.Axis[4].m_Max_Current = 1000;
				m_OutputEtherCAT.Axis[5].m_Max_Current = 1000;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;
				// Homing
			case TaskModuleIndexOffset2:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				m_ButtonFlag = true;
				m_ButtonSet = ButtonHomeingPos;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset3:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				m_ButtonFlag = true;
				m_ButtonSet = ButtonStop;
				m_mode_num = 0;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset4:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				m_ButtonFlag = true;

				pData = &m_logdata;         // ADS Server -> Client Data Update.
				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, sizeof(m_logdata), pData); //sample code

				log_cnt = 0;

				break;
				// 0x5 Ready
			case TaskModuleIndexOffset5:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				// Initial Position
				m_ButtonFlag = true;

				l_initial_motor_pos[0] = ((float)m_InputEtherCAT.Axis[0].m_actual_position * m_ConvertClass._ENC2RAD[0]);
				l_initial_motor_pos[1] = -((float)m_InputEtherCAT.Axis[1].m_actual_position * m_ConvertClass._ENC2RAD[1]);
				l_initial_motor_pos[2] = ((float)m_InputEtherCAT.Axis[2].m_actual_position * m_ConvertClass._ENC2RAD[2]);

				l_initial_link_pos[0] = ((float)(m_InputEtherCAT.Axis[0].m_absolute_actual_position - m_ConvertClass._InitABS[0]) * m_ConvertClass._ABS2RAD[0]);
				l_initial_link_pos[1] = ((float)(m_InputEtherCAT.Axis[1].m_absolute_actual_position - m_ConvertClass._InitABS[1]) * m_ConvertClass._ABS2RAD[1]);
				l_initial_link_pos[2] = ((float)(m_InputEtherCAT.Axis[2].m_absolute_actual_position - m_ConvertClass._InitABS[2]) * m_ConvertClass._ABS2RAD[2]);

				m_OutputEtherCAT.Axis[0].m_mode_of_operation = 10;
				m_OutputEtherCAT.Axis[1].m_mode_of_operation = 10;
				m_OutputEtherCAT.Axis[2].m_mode_of_operation = 10;

				m_OutputEtherCAT.Axis[0].m_control_word = 15;
				m_OutputEtherCAT.Axis[1].m_control_word = 15;
				m_OutputEtherCAT.Axis[2].m_control_word = 15;
				
				
				r_initial_motor_pos[0] = ((float)m_InputEtherCAT.Axis[3].m_actual_position * m_ConvertClass._ENC2RAD[3]);
				r_initial_motor_pos[1] = -((float)m_InputEtherCAT.Axis[4].m_actual_position * m_ConvertClass._ENC2RAD[4]);
				r_initial_motor_pos[2] = ((float)m_InputEtherCAT.Axis[5].m_actual_position * m_ConvertClass._ENC2RAD[5]);

				r_initial_link_pos[0] = ((float)(m_InputEtherCAT.Axis[3].m_absolute_actual_position - m_ConvertClass._InitABS[3]) * m_ConvertClass._ABS2RAD[3]);
				r_initial_link_pos[1] = ((float)(m_InputEtherCAT.Axis[4].m_absolute_actual_position - m_ConvertClass._InitABS[4]) * m_ConvertClass._ABS2RAD[4]);
				r_initial_link_pos[2] = ((float)(m_InputEtherCAT.Axis[5].m_absolute_actual_position - m_ConvertClass._InitABS[5]) * m_ConvertClass._ABS2RAD[5]);

				m_OutputEtherCAT.Axis[3].m_mode_of_operation = 10;
				m_OutputEtherCAT.Axis[4].m_mode_of_operation = 10;
				m_OutputEtherCAT.Axis[5].m_mode_of_operation = 10;

				m_OutputEtherCAT.Axis[3].m_control_word = 15;
				m_OutputEtherCAT.Axis[4].m_control_word = 15;
				m_OutputEtherCAT.Axis[5].m_control_word = 15;

				m_ButtonSet = ButtonStop;
				m_Compensator_start = 1;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset6:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				m_ButtonFlag = true;

				if (m_mode_num == 1)
				{
					m_ButtonSet = ButtonMove;

				}
				else if (m_mode_num == 2)
				{
					m_ButtonSet = ButtonCartesianMove;

				}

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset7:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				m_ButtonFlag = true;
				m_ButtonSet = ButtonDemoRun;
				demo_mode = true;

				//m_ButtonSet = InitPoseComplete;
				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;


			case TaskModuleIndexOffset8:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				m_OutputEtherCAT.Axis[0].m_control_word = 0;
				m_OutputEtherCAT.Axis[1].m_control_word = 0;
				m_OutputEtherCAT.Axis[2].m_control_word = 0;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;


				/////////////////////////////////////////////////////////
				//
				// * Joint Index Update
				// 
				/////////////////////////////////////////////////////////   
			case TaskModuleIndexOffset9:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				//// Joint Index  
				pCounter = (unsigned long *)pData;
				Gain_Index = *pCounter;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, sizeof(pData), pData);
				break;

				/////////////////////////////////////////////////////////
				//
				// * Position Mode Gain Update
				// 
				/////////////////////////////////////////////////////////   
			case TaskModuleIndexOffset10:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.Pos_Pgain[Gain_Index] = *pCountFloat;

				//m_PIDPostion[Gain_Index]->SetGain(m_Client_CMD.Pos_Pgain[Gain_Index], m_Client_CMD.Pos_Igain[Gain_Index], m_Client_CMD.Pos_Dgain[Gain_Index]);

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset11:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.Pos_Igain[Gain_Index] = *pCountFloat;

				//m_PIDPostion[Gain_Index]->SetGain(m_Client_CMD.Pos_Pgain[Gain_Index], m_Client_CMD.Pos_Igain[Gain_Index], m_Client_CMD.Pos_Dgain[Gain_Index]);

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset12:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.Pos_Dgain[Gain_Index] = *pCountFloat;

				//m_PIDPostion[Gain_Index]->SetGain(m_Client_CMD.Pos_Pgain[Gain_Index], m_Client_CMD.Pos_Igain[Gain_Index], m_Client_CMD.Pos_Dgain[Gain_Index]);
				//m_POPCclass->POPC_Intialize(0.0, 0.0, m_Client_CMD.Pos_Pgain[Gain_Index], m_Client_CMD.Pos_Igain[Gain_Index], m_Client_CMD.Pos_Dgain[Gain_Index]);
				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

				/////////////////////////////////////////////////////////
				//
				// * Torque Mode Gain Update
				// 
				/////////////////////////////////////////////////////////   
			case TaskModuleIndexOffset13:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.Torq_Pgain[Gain_Index] = *pCountFloat;

				//m_PIDTorque[Gain_Index]->SetGain(m_Client_CMD.Torq_Pgain[Gain_Index], m_Client_CMD.Torq_Igain[Gain_Index], m_Client_CMD.Torq_Dgain[Gain_Index]);

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset14:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.Torq_Igain[Gain_Index] = *pCountFloat;

				//m_PIDTorque[Gain_Index]->SetGain(m_Client_CMD.Torq_Pgain[Gain_Index], m_Client_CMD.Torq_Igain[Gain_Index], m_Client_CMD.Torq_Dgain[Gain_Index]);

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset15:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.Torq_Dgain[Gain_Index] = *pCountFloat;

				l_m_PIDTorque[Gain_Index]->SetGain(m_Client_CMD.Torq_Pgain[Gain_Index], m_Client_CMD.Torq_Igain[Gain_Index], m_Client_CMD.Torq_Dgain[Gain_Index]);

				r_m_PIDTorque[Gain_Index]->SetGain(m_Client_CMD.Torq_Pgain[Gain_Index], m_Client_CMD.Torq_Igain[Gain_Index], m_Client_CMD.Torq_Dgain[Gain_Index]);

				//m_PIDTorque_gen[Gain_Index]->SetGain(m_Client_CMD.Torq_Pgain[Gain_Index], m_Client_CMD.Torq_Igain[Gain_Index], m_Client_CMD.Torq_Dgain[Gain_Index]);

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;
				/////////////////////////////////////////////////////////
				//
				// * Joint Efficient Const
				// 
				/////////////////////////////////////////////////////////   
			case TaskModuleIndexOffset16:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.J_EffiCont[Gain_Index] = *pCountFloat;

				//Torquecontroller_J[Gain_Index]->SetTorqueControlCoef(0.0, 0.0, 0.0, m_Client_CMD.J_TorqueConst[Gain_Index], 100, m_Client_CMD.J_EffiCont[Gain_Index], 1 / 0.00450, m_Client_CMD.J_SpringConst[Gain_Index]);

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;
				/////////////////////////////////////////////////////////
				//
				// * Joint Torque Const
				// 
				/////////////////////////////////////////////////////////   

			case TaskModuleIndexOffset17:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.J_TorqueConst[Gain_Index] = *pCountFloat;


				//Torquecontroller_J[Gain_Index]->SetTorqueControlCoef(0.0, 0.0, 0.0, m_Client_CMD.J_TorqueConst[Gain_Index], 100, m_Client_CMD.J_EffiCont[Gain_Index], 1 / 0.00450, m_Client_CMD.J_SpringConst[Gain_Index]);

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;
				/////////////////////////////////////////////////////////
				//
				// * Joint Spring Const
				// 
				/////////////////////////////////////////////////////////   
			case TaskModuleIndexOffset18:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.J_SpringConst[Gain_Index] = *pCountFloat;


				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;
			 
			case TaskModuleIndexOffset19:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);


				pCountFloat = (float*)pData;
				m_Client_CMD.CMD_BufferR1[Gain_Index] = *pCountFloat;
				/*
				l_target_pos[Gain_Index] = m_Client_CMD.J_TargetPoistion[Gain_Index];
				l_target_amplitude_tri[Gain_Index] = m_Client_CMD.J_TargetPoistion[Gain_Index];

				r_target_pos[Gain_Index] = m_Client_CMD.J_TargetPoistion[Gain_Index];
				r_target_amplitude_tri[Gain_Index] = m_Client_CMD.J_TargetPoistion[Gain_Index];
				*/
				//target_tor[Gain_Index] = m_Client_CMD.J_TargetPoistion[Gain_Index];// ,      .


				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;
		
			case TaskModuleIndexOffset20:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.CMD_BufferR2[Gain_Index] = *pCountFloat;
				/*
				l_cycle_time_tri = m_Client_CMD.J_TargetTime[Gain_Index];
				l_target_time = m_Client_CMD.J_TargetTime[Gain_Index];

				r_cycle_time_tri = m_Client_CMD.J_TargetTime[Gain_Index];
				r_target_time = m_Client_CMD.J_TargetTime[Gain_Index];
				*/
				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;
		
			case TaskModuleIndexOffset21:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.CMD_BufferR3[Gain_Index] = *pCountFloat;
				/*
				l_accel_time = m_Client_CMD.J_AccelTime[Gain_Index];
				r_accel_time = m_Client_CMD.J_AccelTime[Gain_Index];
				*/
				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;


			case TaskModuleIndexOffset22:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.CMD_BufferL1[Gain_Index] = *pCountFloat;


				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;


			case TaskModuleIndexOffset23:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.CMD_BufferL2[Gain_Index] = *pCountFloat;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset24:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.CMD_BufferL3[Gain_Index] = *pCountFloat;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

				/////////////////////////////////////////////////////////
				//
				// * Robot Mode Select
				// 
				/////////////////////////////////////////////////////////   

			case TaskModuleIndexOffset25:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				//Set Joint Mode
				m_logdata.m_dSystemMode = 1;
				m_mode_num = m_logdata.m_dSystemMode;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset26:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				//Set Cartesian Mode
				m_logdata.m_dSystemMode = 2;
				m_mode_num = m_logdata.m_dSystemMode;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;


				/////////////////////////////////////////////////////////
				//
				// * Cartesian Parameter Setting
				// 
				/////////////////////////////////////////////////////////   

			case TaskModuleIndexOffset27:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.Cartesian_Pgain[Gain_Index] = *pCountFloat;

				l_m_PIDCartesian[Gain_Index]->InitGain();
				l_m_PIDCartesian[Gain_Index]->SetGain(m_Client_CMD.Cartesian_Pgain[Gain_Index],
					m_Client_CMD.Cartesian_Igain[Gain_Index],
					m_Client_CMD.Cartesian_Dgain[Gain_Index]);

				r_m_PIDCartesian[Gain_Index]->InitGain();
				r_m_PIDCartesian[Gain_Index]->SetGain(m_Client_CMD.Cartesian_Pgain[Gain_Index],
					m_Client_CMD.Cartesian_Igain[Gain_Index],
					m_Client_CMD.Cartesian_Dgain[Gain_Index]);

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset28:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.Cartesian_Igain[Gain_Index] = *pCountFloat;

				l_m_PIDCartesian[Gain_Index]->SetGain(m_Client_CMD.Cartesian_Pgain[Gain_Index],
					m_Client_CMD.Cartesian_Igain[Gain_Index],
					m_Client_CMD.Cartesian_Dgain[Gain_Index]);

				r_m_PIDCartesian[Gain_Index]->SetGain(m_Client_CMD.Cartesian_Pgain[Gain_Index],
					m_Client_CMD.Cartesian_Igain[Gain_Index],
					m_Client_CMD.Cartesian_Dgain[Gain_Index]);
				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset29:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.Cartesian_Dgain[Gain_Index] = *pCountFloat;

				l_m_PIDCartesian[Gain_Index]->SetGain(m_Client_CMD.Cartesian_Pgain[Gain_Index],
					m_Client_CMD.Cartesian_Igain[Gain_Index],
					m_Client_CMD.Cartesian_Dgain[Gain_Index]);

				r_m_PIDCartesian[Gain_Index]->SetGain(m_Client_CMD.Cartesian_Pgain[Gain_Index],
					m_Client_CMD.Cartesian_Igain[Gain_Index],
					m_Client_CMD.Cartesian_Dgain[Gain_Index]);

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset30:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.CMD_BufferR4[Gain_Index] = *pCountFloat;

				/*
				l_m_target_pose[0] = m_Client_CMD.C_TargetPoistion[0];
				l_m_target_pose[1] = m_Client_CMD.C_TargetPoistion[1];
				l_m_target_pose[2] = m_Client_CMD.C_TargetPoistion[2];

				r_m_target_pose[0] = m_Client_CMD.C_TargetPoistion[0];
				r_m_target_pose[1] = m_Client_CMD.C_TargetPoistion[1];
				r_m_target_pose[2] = m_Client_CMD.C_TargetPoistion[2];
				*/

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset31:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.CMD_BufferR5[Gain_Index] = *pCountFloat;
				/*
				l_target_time = m_Client_CMD.C_TargetTime[Gain_Index];
				l_cycle_time_tri = m_Client_CMD.C_TargetTime[Gain_Index];

				r_target_time = m_Client_CMD.C_TargetTime[Gain_Index];
				r_cycle_time_tri = m_Client_CMD.C_TargetTime[Gain_Index];
				*/
				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset32:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.CMD_BufferR6[Gain_Index] = *pCountFloat;
				/*
				l_accel_time = m_Client_CMD.C_AccelTime[Gain_Index];
				r_accel_time = m_Client_CMD.C_AccelTime[Gain_Index];
				*/
				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

				/////////////////////////////////////////////////////////
				//
				// * Joint Buffer 2
				// 
				/////////////////////////////////////////////////////////   

			case TaskModuleIndexOffset33:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.CMD_BufferL4[Gain_Index] = *pCountFloat;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;


			case TaskModuleIndexOffset34:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.CMD_BufferL5[Gain_Index] = *pCountFloat;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset35:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				pCountFloat = (float*)pData;
				m_Client_CMD.CMD_BufferL6[Gain_Index] = *pCountFloat;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;

			case TaskModuleIndexOffset36:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				// Normal Controller Select
				m_state_select = 1;
				break;

			case TaskModuleIndexOffset37:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				// Normal Controller Select
				pCountInt = (int *)pData;
				haptic_enable = *pCountInt;

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 4, pData);
				break;
			
			case TaskModuleIndexOffset39:
				m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
					m_objId.value, indexGroup, indexOffset);

				//memcpy(&m_popc_data, pData, sizeof(ADSPOPC_SystemData));
				
				pCountData = (ADSPOPC_SystemData *)pData;
				m_popc_data = *pCountData;
				
				/////////////////////////////////////////////////////////
				//
				// * ADS Server Data Update
				// 
				/////////////////////////////////////////////////////////  

				
				left_popc.force[0] = m_popc_data.left.force[0];
				left_popc.force[1] = m_popc_data.left.force[1];
				left_popc.force[2] = m_popc_data.left.force[2];

				left_popc.s_energy[0] = m_popc_data.left.s_energy[0];
				left_popc.s_energy[1] = m_popc_data.left.s_energy[1];
				left_popc.s_energy[2] = m_popc_data.left.s_energy[2];

				right_popc.force[0] = m_popc_data.right.force[0];
				right_popc.force[1] = m_popc_data.right.force[1];
				right_popc.force[2] = m_popc_data.right.force[2];

				right_popc.s_energy[0] = m_popc_data.right.s_energy[0];
				right_popc.s_energy[1] = m_popc_data.right.s_energy[1];
				right_popc.s_energy[2] = m_popc_data.right.s_energy[2];

				
				

				AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, sizeof(ADSPOPC_SystemData), pData);
				break;
			
			default:
				break;
		}
		break;
	default:
		__super::AdsReadWriteInd(rAddr, invokeId, indexGroup, indexOffset, cbReadLength, cbWriteLength, pData); 
		break;
	}
	m_Trace.Log(tlVerbose, FLEAVEA);
}


void CTaskModule::SubmitAdsReadReq()
{
	m_Trace.Log(tlVerbose, FENTERA);
	// m_ContextAdsPort contains the ADS port number of the task associated with context 1
	// amsAddr refers to the ADS port of this task 
	AmsAddr amsAddr(this->AmsGetNetId(), m_ContextAdsPort);

	// Request the value of a parameter from a TwinCAT module instance
	// via the task ADS port.
	// The object id of the instance is passed as index group and
	// the parameter id is passed as index offset.
	// The result is delivered by a call to AdsReadCon and can 
	// be identified by the invoke id. 
	int nRes = 
		AdsReadReq
		(
			amsAddr, 
			invokeIdReadByOidAndPid, 
			m_objId.value, 
			PID_TaskModuleCounter,
			sizeof(m_ReadByOidAndPid)
		);
	if (nRes != ADSERR_NOERR)
	{
		m_Trace.Log(tlError, FNAMEA "AdsReadReq failed with error=0x%08x(%s)", nRes, AdsGetErrorText(nRes));
	}
	else
	{
		m_Trace.Log(tlInfo, FNAMEA "AdsReadReq by oid=0x%08x and pid=0x%08x", m_objId.value, PID_TaskModuleAdsPort);
	}
	m_Trace.Log(tlVerbose, FLEAVEA);
}

///////////////////////////////////////////////////////////////////////////////
void CTaskModule::AdsReadCon
(
	AmsAddr& rAddr,
	ULONG invokeId,
	ULONG nResult,
	ULONG cbLength,
	PVOID pData
)
{
	m_Trace.Log(tlVerbose, FENTERA "oid=0x%08x, invokeId=%d, nResult=0x%08x, cbLength=%d, pData=0x%p",
		m_objId.value, invokeId, nResult, cbLength, pData);

	if (invokeId == invokeIdReadByOidAndPid)
	{
		if (nResult != ADSERR_NOERR)
		{
			m_Trace.Log(tlWarning, FNAMEA "ReadByOidAndPid failed with error=0x%x(%s)",
				nResult, AdsGetErrorText(nResult));
		}
		else if (cbLength == sizeof(m_ReadByOidAndPid))
		{
			m_ReadByOidAndPid = *static_cast<PULONG>(pData); 
			m_Trace.Log(tlInfo, FNAMEA "m_ReadByOidAndPid=0x%x", m_ReadByOidAndPid);
		}
	}
	else
	{
		__super::AdsReadWriteCon( rAddr, invokeId, nResult, cbLength, pData );
	}
	m_Trace.Log(tlVerbose, FLEAVEA);
}

